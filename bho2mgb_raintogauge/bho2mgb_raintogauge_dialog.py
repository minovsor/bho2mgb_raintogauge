# -*- coding: utf-8 -*-
"""
/***************************************************************************
 BHO2MGB_RainToGaugeDialog
                                 A QGIS plugin
 Converts BHO2MGB rainfall grid to propers formats
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-09-01
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Mino Sorribas
        email                : mino.sorribas@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets



# bibliotecas adicionais.
import json
import pandas as pd
from datetime import date
import numpy as np

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'bho2mgb_raintogauge_dialog_base.ui'))


class BHO2MGB_RainToGaugeDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(BHO2MGB_RainToGaugeDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)        
        
        # ms: processos na janela
        self.pushButton_Main.clicked.connect(self.on_pushButton_Main_run)        
        self.pushButton_Dates.clicked.connect(self.on_pushButton_Dates_run)        
        self.checkBox_Interp.stateChanged.connect(self.on_checkBox_Interp_run)
                  
    
    #  botao principal
    def on_pushButton_Main_run(self):  
        # funcao para testes
        #self._test()
        
        print('\nexecucao BHO2MGB - Raingrid to Gauges')
    
        # obtem arquivo de chuva e pasta para salvar dos campos
        grid_csv = self.mQgsFileWidget_inRainfall.filePath()
        pathout = self.mQgsFileWidget_outFolder.filePath()
        pathout = pathout + "\\"
        
        # obtem arquivo gtp verifica se vai interpolar tbm
        mini_gtp = ''
        flag_interp = self.checkBox_Interp.isChecked()
        if flag_interp:
            mini_gtp = self.mQgsFileWidget_inMini.filePath()
        
        # mostra no console        
        print(grid_csv)
        print(pathout) 
        print(mini_gtp)
        
        # executa
        try:
            print("processo em execução:")
            print('::extraindo series temporais do grid...',end='')
            # 1) converte grid em tripas
            _ = self.grid_to_tripas(grid_csv, pathout)
            print('OK',end='\n')
            
            # 2) realiza interpolacao (se assim quiser)
            if flag_interp:
                print(':interpolação ativada')
                
                #2.1 verifica intervalo de dados
                print('::verificando datas...',end='')
                dini, dfim = self.get_grid_dates(grid_csv)                
                
                if self.check_selected_dates(dini,dfim):
                    print('OK',end='\n')
                else:
                    print('datas inválidas.',end='\n')
                    QtWidgets.QMessageBox.warning(self, "Interpolação:", "Erro: verifique as datas!")
                    return
                
                #2.2 leitura mini.gtp
                print('::lendo mini.gtp...',end='')
                mini_xy = self.read_minigtp(mini_gtp)
                print('OK',end='\n')
                
                #2.3 interpola
                print('::interpolando chuva...',end='')
                self.interpolate(mini_xy, grid_csv, pathout)            
                print('OK',end='\n')
                
                #3 janela de aviso
                QtWidgets.QMessageBox.information(self, "Aviso", "Concluído com sucesso!")
                
            else:            
                print(':interpolação desativada.')
            
            print('processo concluido.',end='\n')
        except:
            print('processo cancelado: erro.')
            QtWidgets.QMessageBox.warning(self, "Erro", "Verifique terminal python!")
            pass
        return 
        
            
    #  checkbox de interpolacao
    def on_checkBox_Interp_run(self):
        ''' liga e desliga opcoes de interpolacao'''
        if self.checkBox_Interp.isChecked():
            trig = True
        else:
            trig = False
        self.mQgsFileWidget_inMini.setEnabled(trig)
        self.dateEdit_Start.setEnabled(trig)
        self.dateEdit_End.setEnabled(trig)
        self.pushButton_Dates.setEnabled(trig)  
        return
        
    
    # botao para obter datas a partir do arquivo de grid
    def on_pushButton_Dates_run(self):        
        try:
            # o arquivo de chuva
            grid_csv = self.mQgsFileWidget_inRainfall.filePath()
            # obtem a data inicial e final
            dini, dfim = self.get_grid_dates(grid_csv)
            # atualiza nos campos da interface
            self.dateEdit_Start.setDate(dini)
            self.dateEdit_End.setDate(dfim)
        except:
            print('verifique o arquivo de grid')
            pass
        return
        
    
    #@staticmethod
    def get_grid_dates(self, grid_csv):
        # le dados
        df = pd.read_csv(grid_csv)                       
        # somente colunas de datas
        df = df.drop(['.geo','system:index'], axis = 1)         
        # obtem e retorna data inicial e final
        datas = pd.to_datetime(df.columns)        
        dini = (min(datas)).date()
        dfim = (max(datas)).date()        
        return dini, dfim
        
        
    #@staticmethod
    def check_selected_dates(self,dini,dfim):
        # obtem datas do formulatio
        d1 = self.dateEdit_Start.date()
        d2 = self.dateEdit_End.date()
        # verifica se a data é valida
        if (d1 >= dini and d2<=dfim and dini<dfim and d1<d2):
            #print(dini,d1,dfim,d2)
            status = True
        else:
            #print(dini,d1,dfim,d2)
            status = False
        return status
        
    
    #@staticmethod
    def read_minigtp(self,mini_gtp):
        try:
            # le mini e armazena matriz de dados
            dados = np.loadtxt(mini_gtp,skiprows=1)
            # salva minibacia e coordenadas
            mini_xy = dados[:,[1,2,3]]            
        except:
            QtWidgets.QMessageBox.information(self, 'Error', 'Check mini.gtp file')
            print('ERRO!')            
        return mini_xy          
    

    #@staticmethod  
    def grid_to_tripas(self, grid_csv, pathout):      

        # le dados
        df = pd.read_csv(grid_csv)
                
        # inclui coordenadas
        df_coords = df.apply(lambda x:json.loads(x['.geo'])['coordinates'], axis = 1, result_type='expand')
        df_coords.columns = ['lon','lat']
        
        # organiza os dados
        df = pd.concat([df,df_coords],axis = 1)
        df = df.iloc[:,1:].drop('.geo',axis=1)
        
        # datas em formato pt-br
        datas = pd.to_datetime( df.columns[:-2] )
        datas_ptbr = datas.strftime('    %d    %m  %Y')
        
        # abre arquivos para cadastro no mgb
        fil_nomes = open(pathout + '_Nomes_Chuva.txt','w')
        fil_estacoes = open(pathout + '_Estacoes1_Chuva.txt','w')
        fil_lats = open(pathout + '_Latitudes1_Chuva.txt','w')
        fil_lons = open(pathout + '_Longitudes1_Chuva.txt','w')
        
        # itera pontos do grid e salva arquivos
        conta = 0
        fmt = {'datas':"{:>18}".format,
               'chuva':"{:>15,.6f}".format}
        files_tripas = []
        for i,row in df.iterrows():
            conta = conta+1
            
            # ajusta dados em formato tripa
            dfp = row[:-2].to_frame()
            dfp.columns = ['chuva']
            dfp['datas'] = datas_ptbr
            dfp = dfp.set_index('datas')
            dfp = dfp.reset_index()
            
            # coordenadas
            lat = row.lat
            lon = row.lon
            
            # salva serie temporal
            filout = pathout + '099' + str(conta).zfill(5) + '.txt'
            with open(filout,'w') as f:
                f.write(dfp.to_string(index = False, header = False, formatters = fmt))
                
            # atualiza arquivos de cadastro
            fil_nomes.write('099' + str(conta).zfill(5) + '\n')
            fil_estacoes.write('099' + str(conta).zfill(5) + '\n')            
            fil_lats.write(f'{lat:.3f}' + '\n')
            fil_lons.write(f'{lon:.3f}' + '\n')
            
            # arquivos de series temporais e coordenadas
            files_tripas.append([filout,lon,lat])
            
        fil_nomes.close()
        fil_estacoes.close()
        fil_lats.close()
        fil_lons.close()
        
        return files_tripas #lista de arquivos com series temporais
        
    def interpolate(self, mini_xy, grid_csv, pathout, p = 2, dmax = 3., filter_dates = True):
    
    
        # obtem o grid
        df = pd.read_csv(grid_csv)
        # inclui coordenadas
        df_coords = df.apply(lambda x:json.loads(x['.geo'])['coordinates'], axis = 1, result_type='expand')
        df_coords.columns = ['lon','lat']
        # remove colunas desnecessarias
        df = df.drop(['.geo','system:index'],axis=1)
  
        # dados vetorizados
        xyg = df_coords.values
        precg = df.values       # grid de chuva [ngrid,nt]

        # datas
        datas = pd.to_datetime( df.columns ) # a partir das colunas do df original.
        d1 = min(datas).strftime('%Y-%m-%d')
        d2 = max(datas).strftime('%Y-%m-%d')
  
        # filtragem de intervalo
        if filter_dates:
            # transpoe o df para obter a sequencia de datas  
            dft = df.T.copy()
            dft['datas'] = datas[:]
            dft = dft.set_index('datas')
            
            # obtem datas dos formulatios e filtra
            d1 = self.dateEdit_Start.date().toString("yyyy-MM-dd")
            d2 = self.dateEdit_End.date().toString("yyyy-MM-dd")
            dft = dft.loc[d1:d2]
        
            # sobrepoe o grid de chuva
            precg = dft.T.values
        

        # loop nas minibacias
        nc = len(mini_xy)
        ng, nt = precg.shape
        #print(nc,ng,nt)
        results = []
        for row in mini_xy:
            
            # mini e coordenadas
            ic = int(row[0])            
            xyc = row[1:]
            
            # distancia ate os pontos de grid
            dx = np.subtract.outer(xyc[0],xyg[:,0])
            dy = np.subtract.outer(xyc[1],xyg[:,1])
            dist = np.hypot(dx,dy)

            # ponderacao inverso distancia
            w = 1./(dist**p)
            w = np.where(np.isinf(w),1.,w)  # evita problemas em pontos proximos
            w = np.where(dist>dmax,0.,w)    # zera grid distante
            w /= w.sum(axis=0)              # normaliza
            w = w[np.newaxis,:]             # [1,ngrid]
            
            # aplica ao longo do tempo e armazena
            i = ic - 1            
            precs = np.dot(w, precg) #.flatten())
            results.append(precs)
            
            #if ic==1:
            #    print(xyc)
            #    print(xyg)
            #    print(dist)
            #    print(1./dist**p)
            #    print(w)
        
        # armazena em matriz e ajusta dimensao para fortran        
        pcalc = np.array(results)
        #print(pcalc)
        '''
        if pcalc.ndim==2:
            pcalc = pcalc.T
        elif (pcalc.ndim==1 and nc==1):
            pcalc = pcalc[:,np.newaxis]
        else:
            print('erro desconhecido')
            QtWidgets.QMessageBox.information(self.iface.mainWindow(), 'Error', 'Check mini.gtp file')
        '''
        # salva em arquivo binario real4 little-endian
        pcalc = pcalc.T
        rainbin = pathout + 'rainbin.pbi'
        _ = np.array(pcalc, order = 'F', dtype='<f4').tofile(rainbin)
        
        # salva arquivo com informacoes em texto.
        with open(pathout + 'rainbin.info','w') as f:
            f.write(f'NT = {nt}\n')
            f.write(f'NC = {nc}\n')
            f.write(f'DINI = {d1}\n')
            f.write(f'DFIM = {d2}\n')
        
        return